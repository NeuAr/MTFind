#include <cstddef>
#include <deque>
#include <exception>
#include <regex>
#include <stdint.h>
#include <string>
#include <thread>
#include <vector>
#include <file_reader.h>
#include <file_search.h>
#include <join_thread.h>

namespace mtfind 
{
	using namespace std;
	using namespace std::experimental::filesystem;

	// Ищет позиции начал строк, соответствующих указанной маске, в указанной строке и возвращает список найденных позиций
	vector<size_t> findPositions(const char* line, const char* mask)
	{
		// Список найденных позиций начал строк, соответствующих переданной маске, в переданной строке
		vector<size_t> results;
		// Позиция начала совпадений символов в переданной строке с символами в переданной маске
		size_t matchStartPosition = 0;
		// Количество совпадений символов в переданной строке с символами в переданной маске
		size_t matchCount = 0;
		
		// Проверяем, являются ли переданные указатели на строку и на маску нулевыми указателями
		if (line != nullptr && mask != nullptr)
		{
			// Если переданные указатели на строку и на маску не являются нулевыми указателями
			// Двигаемся по символам переданной строки, пока не будет достигнут конец строки
			while (*line != '\0')
			{
				// Проверяем, совпадает ли текущий символ в переданной строке с текущим символом в переданной маске
				// Если текущий символ в переданной маске (?), он обозначает любой символ, поэтому совпадение засчитываться без сравнения символов
				if (*line == *mask || *mask == '?')
				{
					// Если текущий символ в переданной строке совпадает с текущим символом в переданной маске
					// Переходим к следующему символу переданной маски 
					// и увеличиваем количество совпадений символов в переданной строке с символами в переданной маске
					++mask;
					++matchCount;
				}
				else
				{
					// Если текущий символ в переданной строке не совпадает с текущим символом в переданной маске
					// Увеличиваем позицию начала совпадений символов в переданной строке с символами в переданной маске
					++matchStartPosition;

					// Если до этого были совпадения символов в переданной строке с символами в переданной маске
					// Откатываемся на количество символов совпадений назад и в переданной строке, и в переданной маске, что-бы начать поиск по новой
					// Сбрасываем количество совпадений символов в переданной строке с символами в переданной маске
					if (matchCount > 0)
					{
						line -= matchCount;
						mask -= matchCount;
						matchCount = 0;
					}
				}

				// Проверяем, был ли достигнут конец строки переданной маски
				if (*mask == '\0')
				{
					// Если конец строки переданной маски был достигнут
					// Считаем, что было найдено совпадение части переданной строки с переданной маской
					// Добавляем позицию начала совпадений символов в переданной строке с символами в переданной маске в список найденных позиций
					// Переводим позицию начала совпадений символов в переданной строке с символами в переданной маске на количество совпадений символов вперёд, 
					// чтобы она соответствовала текущему символу строки
					// Переходим к первому символу переданной маски, чтобы начать поиск заново
					// Количество символов в переданной маске, в данном случае, равно количеству совпадений символов в переданной строке с символами в переданной маске
					// Сбрасываем количество совпадений символов в переданной строке с символами в переданной маске
					results.push_back(matchStartPosition);
					matchStartPosition += matchCount;
					mask -= matchCount;
					matchCount = 0;
				}

				// Переходим к следующему символу переданной строки
				++line;
			}
		}
		
		// Возвращаем cписок найденных позиций начал строк, соответствующих переданной маске, в переданной строке
		return results;
	}

	// Ищет строки, соответствующие указанной маске, в указанной строке и возвращает список найденных строк и их позиции в указанной строке 
	vector<SearchResult> findStrings(const string& line, const string& mask)
	{
		// Список найденных строк, соответствующих переданной маске, и их позиций в переданной строке
		vector<SearchResult> results;

		// Проверяем, являются ли переданные строка и маска пустыми
		if (!line.empty() && !mask.empty())
		{
			// Если переданные строка и маска не являются пустыми
			// Получаем список позиции начал строк, соответствующих переданной маске, в переданной строке
			vector<size_t> stringsPositions = findPositions(line.c_str(), mask.c_str());

			// Проверяем, является ли полученный список позиции начал строк, соответствующих переданной маске, в переданной строке, пустым
			if (!stringsPositions.empty())
			{
				// Если полученный список позиции начал строк, соответствующих переданной маске, в переданной строке, не является пустым
				// Получаем длину строки переданной маски
				size_t maskSize = mask.size();

				// Проходимся по полученному списку позиции начал строк, соответствующих переданной маске, в переданной строке
				for (size_t stringPosition : stringsPositions)
				{
					// Получаем часть переданной строки от текущей найденной позиции начала строки и длиной, как длина строки переданной маски
					// Добавляем полученную часть переданной строки и её позицию в cписок найденных строк
					results.emplace_back((stringPosition + 1), line.substr(stringPosition, maskSize));
				}
			}
		}
		
		// Возвращаем cписок найденных строк, соответствующих переданной маске, и их позиций в переданной строке
		return results;
	}

	/*
		- SearchResult
	*/

	SearchResult::SearchResult(size_t position, string&& text) noexcept
		: position{ position }, text{ move(text) }
	{

	}

	/*
		- LineSearchResult
	*/

	LineSearchResult::LineSearchResult(size_t lineNumber, vector<SearchResult>&& results)
		: lineNumber{ lineNumber }, results{ move(results) }
	{

	}

	/*
		- FileSearchProvider
	*/

	FileSearchProvider::FileSearchProvider(path&& filePath, uintmax_t maxFileSize)
		: filePath_{ move(filePath) }
	{
		// Если файла по переданному пути не существует, выбрасываем исключение
		if (!exists(filePath_))
		{
			throw exception{ "Файла по указанному пути не существует" };
		}

		// Если размер файла по переданному пути, больше переданного максимально допустимого размера файла, выбрасываем исключение
		if (file_size(filePath_) > maxFileSize)
		{
			throw exception{ "Размер указанного файла, больше максимально допустимого размера" };
		}
	}

	bool FileSearchProvider::addSearchError(const string& errorText) noexcept
	{
		try 
		{
			// Устанавливаем блокировку доступа к ошибкам последнего поиска в файле текущим потоком
			unique_lock<mutex> lockerErrors{ lockerErrorsMutex_ };
			// Добавляем ошибку с переданным текстом в конец списка ошибок последнего поиска в файле
			lastSearchErrors_.push_back(errorText);
			// Возвращаем логическое значение, что ошибка поиска в файле была добавлена
			return true;
		}
		catch (...) 
		{
			// В случае, если возникло исключение
			// Возвращаем логическое значение, что ошибка поиска в файле не была добавлена
			return false;
		}
	}

	void FileSearchProvider::clearLastSearchErrors()
	{
		// Устанавливаем блокировку доступа к ошибкам последнего поиска в файле текущим потоком
		unique_lock<mutex> lockerErrors{ lockerErrorsMutex_ };

		// Проверяем, есть ли ошибки последнего поиска в файле
		// Если ошибки последнего поиска в файле есть, удаляем их
		if (!lastSearchErrors_.empty())
		{
			lastSearchErrors_.clear();
		}
	}
	
	void FileSearchProvider::searchStrings(const string& mask, FileSearchResult& fileSearchResult, int threadNumber, intmax_t startPosition, size_t linesCount) noexcept
	{
		try 
		{
			// Создаём объект класса для чтения указанного файла
			FileReader fileReader{ filePath_ };
			// Устанавливаем указатель объекта для чтения файла в переданную позицию
			fileReader.setPosition(startPosition);
			// Результаты поиска строк, соответствующих переданной маске, в строках файла
			deque<LineSearchResult> linesSearchResults;
			// Количество найденных строк, соответствующих переданной маске, в строках файла
			size_t linesFoundCount = 0;
			// Номер строки, с которой поток начнёт чтение строк из указанного файла
			// Так как все потоки читают одинаковое количество строк из указанного файла по порядку, 
			// и порядок читаемых строк распределяется в зависимости от номера потока, 
			// то номер строки, с которой поток начнёт чтение строк из указанного файла равен, 
			// количеству строк, читаемых потоком умноженное на номер потока и плюс 1
			size_t startLineNumber = (threadNumber * linesCount) + 1;

			// Читаем переданное количество строк из указанного файла
			for (size_t readLines = 0; readLines < linesCount; ++readLines)
			{
				// Текущая строка файла
				string fileLine;

				// Читаем строку из указанного файла
				// Если строка из указанного файла не была прочитана, то был достигнут конец указанного файла
				// Завершаем чтение строк из указанного файла
				if (!fileReader.readLine(fileLine))
				{
					break;
				}

				// Проверяем, является ли текущая строка файла пустой
				// Если текущая строка файла является пустой, переходим к следующей строке файла
				if (fileLine.empty())
				{
					continue;
				}

				// Получаем список найденных строк, соответствующих переданной маске, и их позиций в текущей строке файла
				vector<SearchResult> lineSearchResults = findStrings(fileLine, mask);

				// Проверяем, является ли список найденных строк, соответствующих переданной маске, и их позиций в текущей строке файла, пустым
				// Если список найденных строк, соответствующих переданной маске, и их позиций в текущей строке файла не является пустым
				// Добавляем результаты поиска в текущей строке файла в список результатов 
				// и увеличиваем общее количество найденных строк, соответствующих переданной маске, в строках файла
				if (!lineSearchResults.empty())
				{
					linesFoundCount += lineSearchResults.size();
					// Номер текущей строки получаем как сумму номера строки, с которой поток начал чтение строк из указанного файла 
					// и количества уже прочитанных строк из указанного файла
					linesSearchResults.emplace_back((startLineNumber + readLines), move(lineSearchResults));
				}
			}

			// Проверяем, были ли найдены строки, соответствующие переданной маске, в прочитанных строках файла
			if (linesFoundCount > 0)
			{
				// Если строки, соответствующие переданной маске, были найдены в прочитанных строках файла
				// Устанавливаем блокировку доступа к результату поиска в файле текущим потоком
				unique_lock<mutex> lockerResult{ lockerResultMutex_ };
				// Сохраняем результаты поиска строк, соответствующих переданной маске, в прочитанных строках файла 
				// в элемент переданного результата поиска в файле с номером текущего потока
				fileSearchResult.results.at(threadNumber) = move(linesSearchResults);
				// Увеличиваем количество найденных результатов в файле на количество найденных строк, соответствующих переданной маске, в прочитанных строках файла
				fileSearchResult.size += linesFoundCount;
			}
		}
		catch (const exception& e)
		{
			// В случае, если возникло исключение
			// Добавляем ошибку поиска в файле
			addSearchError(e.what());
		}
		catch (...) 
		{
			// В случае, если возникло исключение
			// Добавляем ошибку поиска в файле
			addSearchError("Неизвестная ошибка при поиске строк, соответствующих указанной маске, в строках указанного файла");
		}
	}

	const vector<string>& FileSearchProvider::lastSearchErrors() const noexcept
	{
		// Возвращаем ошибки последнего поиска в файле
		return lastSearchErrors_;
	}

	int FileSearchProvider::minThreadsCount() const noexcept
	{
		// Возвращаем минимальное количество потоков для поиска в файле строк, соответствующих указанной маске
		return MinThreadsCount;
	}

	int FileSearchProvider::maxThreadsCount() const noexcept
	{
		// Возвращаем максимальное количество потоков для поиска в файле строк, соответствующих указанной маске
		return MaxThreadsCount;
	}

	size_t FileSearchProvider::maxMaskSize() const noexcept
	{
		// Возвращаем максимальную длину маски для поиска строк в файле
		return maxMaskSize_;
	}

	void FileSearchProvider::setMaxMaskSize(size_t value)
	{
		// Если переданная максимальная длина маски для поиска строк в файле равна 0, выбрасываем исключение
		if (value == 0)
		{
			throw invalid_argument{ "Максимальная длина маски для поиска строк в файле равна 0" };
		}

		// Сохраняем максимальную длину маски для поиска строк в файле
		maxMaskSize_ = value;
	}

	FileSearchResult FileSearchProvider::search(const string& mask, int threadsCount)
	{
		// Если переданная маска для поиска строк в файле пустая, выбрасываем исключение
		if (mask.empty())
		{
			throw invalid_argument{ "Маска для поиска строк в файле пустая" };
		}

		// Если длина переданной маски для поиска строк в файле больше допустимой, выбрасываем исключение
		if (mask.size() > maxMaskSize_)
		{
			throw invalid_argument{ "Длина маски для поиска строк в файле больше допустимого значения - " + to_string(maxMaskSize_) };
		}

		// Если переданная маска для поиска строк в файле состоит только из символов (?), выбрасываем исключение
		if (regex_search(mask, regex{ "^[\\?]+$" }))
		{
			throw invalid_argument{ "Маска для поиска строк в файле состоит только из символов (?)" };
		}

		// Если переданное количество потоков для поиска в файле строк, соответствующих переданной маске, находиться не в указанном интервале, выбрасываем исключение
		if (threadsCount < MinThreadsCount || threadsCount > MaxThreadsCount)
		{
			throw invalid_argument{ "Количество потоков для поиска в файле строк, соответствующих указанной маске, не находится в интервале от " +
				to_string(MinThreadsCount) + " до " + to_string(MaxThreadsCount) };
		}

		// Очищаем ошибки последнего поиска в файле
		lastSearchErrors_.clear();

		// Результат поиска в файле
		FileSearchResult fileSearchResult;
		
		{
			// Список потоков для поиска в файле строк, соответствующих переданной маске
			vector<JoinThread> searchThreads;

			{
				// Создаём объект класса для чтения указанного файла
				FileReader fileReader{ filePath_ };
				// Список позиций начал строк в указанном файле
				deque<intmax_t> linesPositions;

				// Ищем позиции начал строк в указанном файле, пока не будет достигнут конец файла
				do
				{
					// Добавляем текущую позицию указателя объекта для чтения указанного файла в список позиций начал строк в указанном файле
					linesPositions.push_back(fileReader.position());
				} while (fileReader.seekNextLine());

				// Получаем количество строк в указанном файле
				size_t linesCount = linesPositions.size();

				// Проверяем, больше ли количество строк в указанном файле, переданного количества потоков для поиска в файле строк, соответствующих переданной маске
				if (threadsCount > linesCount)
				{
					// Если количество потоков для поиска в файле строк, соответствующих переданной маске, больше количества строк в указанном файле
					// Делаем количество потоков для поиска в файле строк, соответствующих переданной маске, равным количеству строк в указанном файле, 
					// что-бы не запускать лишние потоки впустую
					threadsCount = linesCount;
				}

				// Получаем количество строк указанного файла для поиска строк, соответствующих переданной маске, одним потоком
				// Для этого делим общее количество строк в указанном файле на количество потоков для поиска в файле строк, соответствующих переданной маске, 
				// и приводим к целому числу
				size_t threadLinesCount = static_cast<size_t>((linesCount / threadsCount));

				// Проверяем, есть ли остаток при делении количества строк в указанном файле на количество потоков для поиска в файле строк, соответствующих переданной маске
				if ((linesCount % threadsCount) != 0)
				{
					// Если есть остаток при делении количества строк в указанном файле на количество потоков для поиска в файле строк, соответствующих переданной маске, 
					// то добавляем один к количеству строк указанного файла для поиска строк, соответствующих переданной маске, одним потоком, 
					// что-бы разделить строки указанного файла из остатка между потоками
					++threadLinesCount;
				}

				// Резервируем место в списке потоков для поиска в файле строк, соответствующих переданной маске, для нужного количества потоков
				searchThreads.reserve(threadsCount);
				// Резервируем место в списке результатов поиска в файле строк, соответствующих переданной маске, для нужного количества потоков
				fileSearchResult.results.reserve(threadsCount);

				// Создаём нужное количество потоков для поиска в файле строк, соответствующих переданной маске, и добавляем их в список
				for (int threadNumber = 0; threadNumber < threadsCount; ++threadNumber)
				{
					// Получаем номер строки в списке позиций начал строк в указанном файле, 
					// с которой текущий поток будет начинать поиск строк, соответствующих переданной маске
					// Умножаем номер текущего потока на количество строк указанного файла для поиска строк, соответствующих переданной маске, одним потоком 
					size_t threadStartLineNumber = threadNumber * threadLinesCount;

					// Проверяем, есть ли в списке позиций начал строк в указанном файле, строка с полученным номером, 
					// с которой текущий поток будет начинать поиск строк, соответствующих переданной маске
					if (threadStartLineNumber >= linesCount)
					{
						// В списке позиций начал строк нет строки с полученным номером, 
						// с которой текущий поток будет начинать поиск строк, соответствующих переданной маске
						// Значит, больше потоков для поиска в файле строк, соответствующих переданной маске, не требуется
						// Завершаем создание потоков для поиска в файле строк, соответствующих переданной маске, и добавление их в список
						break;
					}

					{
						// Устанавливаем блокировку доступа к результату поиска в файле текущим потоком
						unique_lock<mutex> lockerResult{ lockerResultMutex_ };
						// Добавляем в результат поиска в файле элемент для сохранения результатов поиска строк, соответствующих переданной маске, текущим потоком
						fileSearchResult.results.emplace_back();
					}
				
					// Создаём текущий поток для поиска в файле строк, соответствующих переданной маске, и добавляем его в список
					searchThreads.emplace_back(thread{ &FileSearchProvider::searchStrings, this, ref(mask), ref(fileSearchResult),
						threadNumber, linesPositions.at(threadStartLineNumber), threadLinesCount });
				}
			}
		}	

		// Возвращаем результат поиска в файле
		return fileSearchResult;
	}
}